<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Priority Queues — Huffman Trace Timing (Hover Tooltips)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --fg:#111827; --muted:#6b7280; --border:#e5e7eb; --card:#ffffff; --bg:#f8fafc; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", sans-serif; }
  .container { max-width: 1040px; margin: 24px auto; padding: 0 16px; }
  h1 { font-size: 1.25rem; margin: 0 0 12px 0; }
  .card { background: var(--card); border:1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 16px; }
  .row { display:flex; gap:12px; flex-wrap: wrap; align-items: center; }
  label { display:flex; align-items:center; gap:8px; }
  input[type="file"] { padding:6px 8px; }
  #chart { height: 500px; position: relative; }
  .legend { display:flex; gap:12px; flex-wrap: wrap; margin-top: 8px; }
  .badge { display:inline-flex; align-items:center; gap:8px; padding:4px 10px; border:1px solid var(--border); border-radius: 999px; background:#fff; font-size: 12px; }
  .dot { width:10px; height:10px; border-radius:999px; display:inline-block; }
  .footer { color: var(--muted); font-size: .9rem; margin-top: 12px; }
  .axis text { font-size: 12px; fill: #374151; }
  .axis path, .axis line { stroke: #94a3b8; }
  .grid line { stroke: #e5e7eb; }
  .grid .domain { display: none; }
  .title { font-weight: 600; margin-bottom: 6px; }
  button { padding: 6px 10px; border: 1px solid var(--border); border-radius: 8px; background: #f9fafb; cursor: pointer; }
  button:hover { background:#f3f4f6; }
  /* Tooltip */
  .tooltip {
    position: fixed;
    pointer-events: none;
    background: #fff;
    border: 1px solid var(--border);
    box-shadow: 0 4px 14px rgba(0,0,0,0.12);
    border-radius: 10px;
    padding: 8px 10px;
    font-size: 12px;
    color: var(--fg);
    z-index: 20;
    white-space: nowrap;
  }
  .tooltip .hdr { font-weight: 600; margin-bottom: 2px; }
  .tooltip .sub { color: var(--muted); }
</style>
</head>
<body>
  <div class="container">
    <h1>Priority Queues — Huffman Trace Timing (Multiple Implementations)</h1>

    <div class="card">
      <div class="row">
        <label>CSV file <input type="file" id="file" accept=".csv" /></label>
        <button id="useDefault">Load example data</button>
        <label><input type="checkbox" id="toggleNlogN"> N log N baseline (anchored to <code>binary_heap</code>)</label>
      </div>
    </div>

    <div id="chart" class="card"></div>
    <div id="legend" class="legend"></div>
    <div class="footer">
      X-axis is log₂ and starts at 2¹⁰. Rows with N &lt; 2¹⁰ are omitted by design.<br/>
      Expected columns: <code>impl,profile,trace_path,N,seed,elapsed_ms,ops_total,inserts,findmins,deletemins,extractmins</code>
    </div>
  </div>

  <!-- D3 v7 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  // Default CSV (refreshed; removed the highest quadratic row as requested)
  const defaultCsv = `impl,profile,trace_path,N,seed,elapsed_ms,ops_total,inserts,findmins,deletemins,extractmins
quadratic_oracle,batch_then_drain,batch_then_drain_N_1024_S_23.trace,1024,23,15.0621,2048,1024,0,0,1024
binary_heap,batch_then_drain,batch_then_drain_N_1024_S_23.trace,1024,23,0.5246,2048,1024,0,0,1024
binomial_queue,batch_then_drain,batch_then_drain_N_1024_S_23.trace,1024,23,1.6242,2048,1024,0,0,1024
linear_base,batch_then_drain,batch_then_drain_N_1024_S_23.trace,1024,23,0.0447,2048,1024,0,0,1024
binary_heap,batch_then_drain,batch_then_drain_N_1048576_S_23.trace,1048576,23,1162.95,2097152,1048576,0,0,1048576
binomial_queue,batch_then_drain,batch_then_drain_N_1048576_S_23.trace,1048576,23,3855.09,2097152,1048576,0,0,1048576
linear_base,batch_then_drain,batch_then_drain_N_1048576_S_23.trace,1048576,23,43.8755,2097152,1048576,0,0,1048576
binary_heap,batch_then_drain,batch_then_drain_N_131072_S_23.trace,131072,23,114.404,262144,131072,0,0,131072
binomial_queue,batch_then_drain,batch_then_drain_N_131072_S_23.trace,131072,23,377.671,262144,131072,0,0,131072
linear_base,batch_then_drain,batch_then_drain_N_131072_S_23.trace,131072,23,5.2648,262144,131072,0,0,131072
quadratic_oracle,batch_then_drain,batch_then_drain_N_13_S_23.trace,13,23,0.0036,26,13,0,0,13
binary_heap,batch_then_drain,batch_then_drain_N_13_S_23.trace,13,23,0.0031,26,13,0,0,13
binomial_queue,batch_then_drain,batch_then_drain_N_13_S_23.trace,13,23,0.012,26,13,0,0,13
linear_base,batch_then_drain,batch_then_drain_N_13_S_23.trace,13,23,0.0011,26,13,0,0,13
quadratic_oracle,batch_then_drain,batch_then_drain_N_16384_S_23.trace,16384,23,3464.2,32768,16384,0,0,16384
binary_heap,batch_then_drain,batch_then_drain_N_16384_S_23.trace,16384,23,15.9566,32768,16384,0,0,16384
binomial_queue,batch_then_drain,batch_then_drain_N_16384_S_23.trace,16384,23,36.4355,32768,16384,0,0,16384
linear_base,batch_then_drain,batch_then_drain_N_16384_S_23.trace,16384,23,0.8976,32768,16384,0,0,16384
quadratic_oracle,batch_then_drain,batch_then_drain_N_2048_S_23.trace,2048,23,56.5096,4096,2048,0,0,2048
binary_heap,batch_then_drain,batch_then_drain_N_2048_S_23.trace,2048,23,1.1255,4096,2048,0,0,2048
binomial_queue,batch_then_drain,batch_then_drain_N_2048_S_23.trace,2048,23,3.2197,4096,2048,0,0,2048
linear_base,batch_then_drain,batch_then_drain_N_2048_S_23.trace,2048,23,0.1205,4096,2048,0,0,2048
binary_heap,batch_then_drain,batch_then_drain_N_262144_S_23.trace,262144,23,249.998,524288,262144,0,0,262144
binomial_queue,batch_then_drain,batch_then_drain_N_262144_S_23.trace,262144,23,799.733,524288,262144,0,0,262144
linear_base,batch_then_drain,batch_then_drain_N_262144_S_23.trace,262144,23,16.4994,524288,262144,0,0,262144
quadratic_oracle,batch_then_drain,batch_then_drain_N_32768_S_23.trace,32768,23,13415.5,65536,32768,0,0,32768
binary_heap,batch_then_drain,batch_then_drain_N_32768_S_23.trace,32768,23,25.1615,65536,32768,0,0,32768
binomial_queue,batch_then_drain,batch_then_drain_N_32768_S_23.trace,32768,23,76.683,65536,32768,0,0,32768
linear_base,batch_then_drain,batch_then_drain_N_32768_S_23.trace,32768,23,1.4685,65536,32768,0,0,32768
quadratic_oracle,batch_then_drain,batch_then_drain_N_4096_S_23.trace,4096,23,206.697,8192,4096,0,0,4096
binary_heap,batch_then_drain,batch_then_drain_N_4096_S_23.trace,4096,23,2.7505,8192,4096,0,0,4096
binomial_queue,batch_then_drain,batch_then_drain_N_4096_S_23.trace,4096,23,6.793,8192,4096,0,0,4096
linear_base,batch_then_drain,batch_then_drain_N_4096_S_23.trace,4096,23,0.1636,8192,4096,0,0,4096
binary_heap,batch_then_drain,batch_then_drain_N_524288_S_23.trace,524288,23,543.796,1048576,524288,0,0,524288
binomial_queue,batch_then_drain,batch_then_drain_N_524288_S_23.trace,524288,23,1718.15,1048576,524288,0,0,524288
linear_base,batch_then_drain,batch_then_drain_N_524288_S_23.trace,524288,23,21.3225,1048576,524288,0,0,524288
binary_heap,batch_then_drain,batch_then_drain_N_65536_S_23.trace,65536,23,55.2873,131072,65536,0,0,65536
binomial_queue,batch_then_drain,batch_then_drain_N_65536_S_23.trace,65536,23,163.308,131072,65536,0,0,65536
linear_base,batch_then_drain,batch_then_drain_N_65536_S_23.trace,65536,23,2.755,131072,65536,0,0,65536
quadratic_oracle,batch_then_drain,batch_then_drain_N_8192_S_23.trace,8192,23,895.789,16384,8192,0,0,8192
binary_heap,batch_then_drain,batch_then_drain_N_8192_S_23.trace,8192,23,5.6133,16384,8192,0,0,8192
binomial_queue,batch_then_drain,batch_then_drain_N_8192_S_23.trace,8192,23,18.2057,16384,8192,0,0,8192
linear_base,batch_then_drain,batch_then_drain_N_8192_S_23.trace,8192,23,0.4914,16384,8192,0,0,8192`;

  // Fixed colors + fallback palette
  const fixedColors = {
    quadratic_oracle: '#000000', // black
    binary_heap:      '#1f77b4', // blue
    binomial_queue:   '#ff7f0e', // orange
    linear_base:      '#2ca02c'  // green
  };
  const fallbackPalette = [
    '#d62728', // red
    '#9467bd', // purple
    '#8c564b', // brown
    '#e377c2', // pink
    '#7f7f7f', // gray
    '#bcbd22', // olive
    '#17becf'  // teal
  ];

  let allRows = [];
  const fileInput = document.getElementById('file');
  const useDefaultBtn = document.getElementById('useDefault');
  const toggleNlogN = document.getElementById('toggleNlogN');

  // Tooltip element (global)
  const tooltip = d3.select('body').append('div')
    .attr('class', 'tooltip')
    .style('opacity', 0);

  useDefaultBtn.addEventListener('click', () => {
    const rows = d3.csvParse(defaultCsv.trim());
    rows.forEach(r => { r.N = +r.N; r.elapsed_ms = +r.elapsed_ms; });
    allRows = rows;
    render();
  });
  toggleNlogN.addEventListener('change', render);

  fileInput.addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      const text = reader.result.replace(/\r\n/g, '\n').trim();
      const rows = d3.csvParse(text);
      rows.forEach(r => { r.N = +r.N; r.elapsed_ms = +r.elapsed_ms; });
      allRows = rows;
      render();
    };
    reader.readAsText(f);
  });

  function render() {
    // Filter out N < 2^10
    const rows = allRows.filter(r => Number.isFinite(r.N) && Number.isFinite(r.elapsed_ms) && r.N >= 1024);
    const byImpl = d3.groups(rows, d => d.impl);
    byImpl.forEach(([impl, arr]) => arr.sort((a,b)=>a.N-b.N));

    const container = d3.select('#chart');
    container.selectAll('*').remove();

    const margin = {top: 24, right: 34, bottom: 56, left: 76}; // right +10 as requested
    const width = Math.max(360, container.node().clientWidth) - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = container.append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom);

    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    if (!rows.length) {
      g.append('text')
        .attr('x', width/2).attr('y', height/2)
        .attr('text-anchor', 'middle')
        .style('fill', '#6b7280')
        .text('Load a CSV (or click “Load example data”)');
      d3.select('#legend').html('');
      return;
    }

    // X: log2 scale starting at 2^10
    const Nmin = d3.min(rows, d => d.N);
    const Nmax = d3.max(rows, d => d.N);
    const minPow = Math.max(10, Math.ceil(Math.log2(Nmin)));
    const maxPow = Math.floor(Math.log2(Nmax));
    const xTicks = d3.range(minPow, maxPow + 1).map(k => 2 ** k);

    const x = d3.scaleLog().base(2)
      .domain([2 ** minPow, 2 ** maxPow])
      .range([0, width]);

    // Y: elapsed_ms linear (no locking)
    const yMax = d3.max(rows, d => d.elapsed_ms);
    const y = d3.scaleLinear()
      .domain([0, yMax]).nice()
      .range([height, 0]);

    // Axes & grid
    const xAxis = d3.axisBottom(x)
      .tickValues(xTicks)
      .tickFormat(d => `2^${Math.round(Math.log2(d))}`);
    const yAxis = d3.axisLeft(y).ticks(8);

    const xGrid = d3.axisBottom(x).tickValues(xTicks).tickSize(-height).tickFormat('');
    const yGrid = d3.axisLeft(y).ticks(8).tickSize(-width).tickFormat('');

    g.append('g').attr('class','grid').attr('transform', `translate(0,${height})`).call(xGrid);
    g.append('g').attr('class','grid').call(yGrid);

    g.append('g').attr('class','axis').attr('transform', `translate(0,${height})`).call(xAxis);
    g.append('g').attr('class','axis').call(yAxis);

    g.append('text').attr('x', width/2).attr('y', height+42).attr('text-anchor','middle').text('N (2^k)');
    g.append('text').attr('transform','rotate(-90)').attr('x', -height/2).attr('y', -56).attr('text-anchor','middle').text('elapsed_ms');

    // Build a color map for implementations (fixed first, then fallback palette as needed)
    const assigned = new Map();
    let fp = 0;
    byImpl.forEach(([impl]) => {
      assigned.set(impl, fixedColors[impl] || fallbackPalette[(fp++) % fallbackPalette.length]);
    });

    // Line + points per impl
    const line = d3.line()
      .x(d => x(d.N))
      .y(d => y(d.elapsed_ms))
      .curve(d3.curveMonotoneX);

    byImpl.forEach(([impl, arr]) => {
      const col = assigned.get(impl);
      g.append('path')
        .datum(arr)
        .attr('fill','none')
        .attr('stroke', col)
        .attr('stroke-width', 2.5)
        .attr('d', line);

      g.selectAll(`.pt-${cssSafe(impl)}`)
        .data(arr)
        .enter().append('circle')
        .attr('class', `pt-${cssSafe(impl)}`)
        .attr('r', 4)
        .attr('cx', d => x(d.N))
        .attr('cy', d => y(d.elapsed_ms))
        .attr('fill', col)
        .on('mouseenter', function(evt, d) {
          const k = Math.log2(d.N);
          const powLabel = Number.isInteger(k) ? ` (2^${k})` : '';
          const html = `<div class="hdr">${d.impl}</div>
                        <div class="sub">N = ${d.N}${powLabel}</div>
                        <div>elapsed_ms = ${d.elapsed_ms.toFixed(3)}</div>
                        <div class="sub">seed ${d.seed} • ${d.profile}</div>`;
          tooltip.html(html)
            .style('opacity', 1)
            .style('border-left', `4px solid ${assigned.get(d.impl)}`);
          d3.select(this).attr('r', 6);
        })
        .on('mousemove', function(evt) {
          const pad = 12;
          const xPos = evt.clientX + pad;
          const yPos = evt.clientY + pad;
          tooltip.style('left', `${xPos}px`).style('top', `${yPos}px`);
        })
        .on('mouseleave', function() {
          tooltip.style('opacity', 0);
          d3.select(this).attr('r', 4);
        });
    });

    // Optional N log N baseline (dashed gray), ANCHORED TO binary_heap at its leftmost N
    if (toggleNlogN.checked) {
      const heapRows = rows.filter(r => r.impl === 'binary_heap');
      if (heapRows.length) {
        const leftHeapN = d3.min(heapRows, d => d.N);
        const atLeft = heapRows.filter(r => r.N === leftHeapN);
        const ref = d3.mean(atLeft, d => d.elapsed_ms);
        const scale = ref / (leftHeapN * Math.log2(leftHeapN));

        const baseline = xTicks.map(N => ({ N, y: scale * N * Math.log2(N) }));
        const baselineLine = d3.line()
          .x(d => x(d.N))
          .y(d => y(d.y))
          .curve(d3.curveMonotoneX);

        g.append('path')
          .datum(baseline)
          .attr('fill', 'none')
          .attr('stroke', '#6b7280')          // muted gray
          .attr('stroke-dasharray', '6,4')
          .attr('stroke-width', 2)
          .attr('d', baselineLine);

        // legend entry for baseline
        const legend = d3.select('#legend');
        legend.html('');
        byImpl.forEach(([impl]) => {
          const item = legend.append('div').attr('class','badge');
          item.append('span').attr('class','dot').style('background', assigned.get(impl));
          item.append('span').text(impl);
        });
        const item = legend.append('div').attr('class','badge');
        const swatch = item.append('span').attr('class','dot').style('background', '#6b7280');
        swatch.style('border', '2px dashed #6b7280').style('background', 'transparent').style('width','12px').style('height','12px');
        item.append('span').text('N log N baseline (anchored to binary_heap)');
      }
    } else {
      // legend without baseline
      const legend = d3.select('#legend');
      legend.html('');
      byImpl.forEach(([impl]) => {
        const item = legend.append('div').attr('class','badge');
        item.append('span').attr('class','dot').style('background', assigned.get(impl));
        item.append('span').text(impl);
      });
    }
  }

  function cssSafe(s) {
    return String(s).replace(/[^a-zA-Z0-9_-]/g, '_');
  }

  // Auto-load the example on first paint
  (function init() {
    const rows = d3.csvParse(defaultCsv.trim());
    rows.forEach(r => { r.N = +r.N; r.elapsed_ms = +r.elapsed_ms; });
    allRows = rows;
    render();
  })();
  </script>
</body>
</html>
